<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Chat Streaming Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Noto Sans", "Microsoft Yahei", sans-serif; margin: 24px; }
    .row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; }
    textarea { width: 100%; height: 120px; }
    #log { white-space: pre-wrap; background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; min-height: 140px; }
    .pill { padding: 4px 10px; border-radius: 999px; background: #e2e8f0; font-size: 12px; }
    button { padding: 8px 14px; border: none; border-radius: 8px; background: #2563eb; color: #fff; cursor: pointer; }
    button.secondary { background: #64748b; }
    button:disabled { background: #94a3b8; cursor: not-allowed; }
    input, select { padding: 6px 10px; border: 1px solid #cbd5e1; border-radius: 8px; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    .section { border: 1px solid #e2e8f0; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  </style>
</head>
<body>
  <h2>Voice Chat Streaming Demo</h2>
  <div class="row">
    <span class="pill" id="status">Disconnected</span>
    <label>WS URL <input id="wsUrl" value="ws://localhost:8123/ws/voice-chat" style="width: 320px"></label>
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect" class="secondary" disabled>Disconnect</button>
  </div>

  <div class="section">
    <div class="row">
      <label>groupId <input id="groupId" type="number" value="1" style="width: 100px"></label>
      <label>voiceType
        <select id="voiceType" style="width: 260px">
          <option value="qiniu_zh_female_tmjxxy">qiniu_zh_female_tmjxxy</option>
        </select>
      </label>
      <label>speedRatio <input id="speedRatio" type="number" step="0.1" min="0.5" max="2.0" value="1.0" style="width: 100px"></label>
      <label>audioFormat <input id="audioFormat" value="raw" style="width: 100px"></label>
      <button id="btnStart" disabled>Start</button>
      <button id="btnStop" class="secondary" disabled>Stop</button>
      <button id="btnMicStart" disabled>Start Mic</button>
      <button id="btnMicStop" class="secondary" disabled>Stop Mic</button>
    </div>
  </div>

  <div class="section">
    <div class="col">
      <label>Send text</label>
      <div class="row">
        <input id="inputText" placeholder="请输入要对话的文本..." style="flex: 1;" />
        <button id="btnSendText" disabled>Send</button>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="col">
      <label>Streaming logs</label>
      <div id="log"></div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const log = (msg) => {
      const el = $("log");
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
    };

    let ws = null;
    let connected = false;

    // Microphone streaming state
    let audioCtx = null;
    let mediaStream = null;
    let sourceNode = null;
    let processorNode = null;
    const TARGET_SR = 16000;

    // Audio queue per sentence
    const audioQueue = [];
    let currentChunks = [];
    let playing = false;

    function playNext() {
      if (playing) return;
      const item = audioQueue.shift();
      if (!item) return;
      playing = true;
      // item: Array<Uint8Array>
      let total = 0;
      for (const chunk of item) total += chunk.length;
      if (total === 0) {
        log('[audio] skip empty audio segment');
        playing = false;
        playNext();
        return;
      }
      const combined = new Uint8Array(total);
      let offset = 0;
      for (const chunk of item) { combined.set(chunk, offset); offset += chunk.length; }
      const blob = new Blob([combined], { type: 'audio/mpeg' });
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      audio.preload = 'auto';
      let watchdog = null;

      audio.onended = () => {
        if (watchdog) { clearTimeout(watchdog); watchdog = null; }
        URL.revokeObjectURL(url);
        playing = false;
        playNext();
      };
      audio.onerror = () => {
        log('[audio] error event, skip to next');
        if (watchdog) { clearTimeout(watchdog); watchdog = null; }
        try { URL.revokeObjectURL(url); } catch (e) {}
        playing = false;
        playNext();
      };
      audio.onstalled = () => {
        log('[audio] stalled, will rely on watchdog');
      };
      // 如果 30 秒内没有结束（某些浏览器不触发 ended），强制推进
      watchdog = setTimeout(() => {
        log('[audio] watchdog timeout, force next');
        try { URL.revokeObjectURL(url); } catch (e) {}
        try { audio.pause(); } catch (e) {}
        playing = false;
        playNext();
      }, 30000);
      audio.play().catch(err => {
        log('[audio] play error: ' + err);
        if (watchdog) { clearTimeout(watchdog); watchdog = null; }
        playing = false;
        // try next item to avoid blocking
        playNext();
      });
    }

    function computeDefaultWsUrl() {
      const origin = location.origin.replace(/^http/, 'ws');
      // Detect context-path by checking if pathname starts with /api
      const m = location.pathname.match(/^\/(api)(?:\/.+)?$/);
      const ctx = m ? '/' + m[1] : '';
      return origin + ctx + '/ws/voice-chat';
    }

    function computeApiBase() {
      const origin = location.origin;
      const m = location.pathname.match(/^\/(api)(?:\/.+)?$/);
      const ctx = m ? '/' + m[1] : '';
      return origin + ctx;
    }

    function b64ToBytes(b64) {
      try {
        // Remove any characters outside the base64 alphabet (safety)
        const cleaned = (b64 || '').replace(/[^A-Za-z0-9+/=]/g, '');
        const byteChars = atob(cleaned);
        const bytes = new Uint8Array(byteChars.length);
        for (let i = 0; i < byteChars.length; i++) {
          bytes[i] = byteChars.charCodeAt(i);
        }
        return bytes;
      } catch (e) {
        log('[audio] base64 decode error: ' + (e && e.message ? e.message : e));
        return new Uint8Array();
      }
    }

    async function loadVoiceList() {
      try {
        const url = computeApiBase() + '/voice/list';
        const resp = await fetch(url);
        if (!resp.ok) {
          log('[voice] list fetch failed: ' + resp.status + ' ' + resp.statusText);
          return;
        }
        const arr = await resp.json();
        if (!Array.isArray(arr)) {
          log('[voice] unexpected list format');
          return;
        }
        const sel = $('voiceType');
        const preferred = 'qiniu_zh_female_tmjxxy';
        sel.innerHTML = '';
        let hasPreferred = false;
        for (const v of arr) {
          const vt = v.voice_type || v.voiceType || '';
          const vn = v.voice_name || v.voiceName || vt;
          if (!vt) continue;
          const opt = document.createElement('option');
          opt.value = vt;
          opt.textContent = vn ? (vn + ' (' + vt + ')') : vt;
          sel.appendChild(opt);
          if (vt === preferred) hasPreferred = true;
        }
        if (hasPreferred) sel.value = preferred;
        log('[voice] list loaded: ' + sel.options.length + ' items');
      } catch (e) {
        log('[voice] list load error: ' + (e && e.message ? e.message : e));
      }
    }

    function setConnected(v) {
      connected = v;
      $('status').textContent = v ? 'Connected' : 'Disconnected';
      $('btnConnect').disabled = v;
      $('btnDisconnect').disabled = !v;
      $('btnStart').disabled = !v;
      $('btnStop').disabled = !v;
      $('btnSendText').disabled = !v;
      $('btnMicStart').disabled = !v;
      $('btnMicStop').disabled = !v;
    }

    // Initialize default WS URL based on current page path (handles /api prefix)
    (function initDefaultWsUrl() {
      const input = $('wsUrl');
      if (input && (!input.value || input.value.includes('/ws/voice-chat'))) {
        input.value = computeDefaultWsUrl();
      }
    })();

    // Load voice list on page ready
    loadVoiceList();

    $('btnConnect').onclick = () => {
      const url = $('wsUrl').value.trim();
      ws = new WebSocket(url);

      ws.onopen = () => {
        setConnected(true);
        log('[ws] opened');
      };
      ws.onclose = (e) => {
        setConnected(false);
        log('[ws] closed: ' + e.code + ' ' + e.reason);
      };
      ws.onerror = (e) => {
        log('[ws] error');
      };
      ws.onmessage = (evt) => {
        try {
          const data = JSON.parse(evt.data);
          switch (data.type) {
            case 'started':
              log('[server] started');
              break;
            case 'llm_partial':
              log('[llm] ' + data.text);
              break;
            case 'tts_start':
              currentChunks = [];
              log('[tts] start: ' + (data.text || ''));
              break;
            case 'tts_chunk':
              if (data.data) {
                const bytes = b64ToBytes(data.data);
                if (bytes && bytes.length > 0) {
                  currentChunks.push(bytes);
                  log('[tts] chunk bytes: ' + bytes.length);
                } else {
                  log('[tts] empty/invalid chunk ignored');
                }
              } else {
                log('[tts] empty chunk ignored');
              }
              break;
            case 'tts_done':
              if (currentChunks.length > 0) {
                const total = currentChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(total);
                let offset = 0;
                for (const chunk of currentChunks) {
                  combined.set(chunk, offset);
                  offset += chunk.length;
                }
                audioQueue.push([combined]);
                playNext();
              } else {
                log('[tts] done with no chunks, skip enqueue');
              }
              currentChunks = [];
              log('[tts] done');
              break;
            case 'error':
              log('[error] ' + data.message);
              break;
            default:
              log('[server] ' + evt.data);
              break;
          }
        } catch (err) {
          // maybe non-JSON
          log('[msg] ' + evt.data);
        }
      };
    };

    $('btnDisconnect').onclick = () => {
      if (ws) ws.close();
    };

    $('btnStart').onclick = () => {
      if (!ws || !connected) return;
      const payload = {
        type: 'start',
        groupId: Number($('groupId').value) || 0,
        voiceType: $('voiceType').value || 'qiniu_zh_female_tmjxxy',
        speedRatio: Number($('speedRatio').value) || 1.0,
        audioFormat: $('audioFormat').value || 'raw'
      };
      ws.send(JSON.stringify(payload));
      log('[client] start sent');
    };

    $('btnStop').onclick = () => {
      if (!ws || !connected) return;
      ws.send(JSON.stringify({ type: 'stop' }));
      log('[client] stop sent');
    };

    $('btnSendText').onclick = () => {
      if (!ws || !connected) return;
      const text = $('inputText').value.trim();
      if (!text) return;
      ws.send(JSON.stringify({ type: 'user_text', text }));
      log('[client] user_text sent');
    };

    // --- Microphone capture to 16k PCM streaming ---
    $('btnMicStart').onclick = async () => {
      if (!ws || !connected) return;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 1, noiseSuppression: true, echoCancellation: true }, video: false });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioCtx.createMediaStreamSource(mediaStream);
        const bufferSize = 4096; // ~85ms at 48k
        processorNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
        const inputSR = audioCtx.sampleRate; // often 44100 or 48000

        processorNode.onaudioprocess = (e) => {
          const input = e.inputBuffer.getChannelData(0);
          const down = downsampleBuffer(input, inputSR, TARGET_SR);
          const pcm16 = floatTo16BitPCM(down);
          if (ws && connected && pcm16 && pcm16.byteLength > 0) {
            ws.send(pcm16.buffer);
          }
        };

        sourceNode.connect(processorNode);
        processorNode.connect(audioCtx.destination);
        log('[mic] started, SR=' + inputSR + ' -> ' + TARGET_SR);
      } catch (err) {
        log('[mic] error: ' + err.message);
      }
    };

    $('btnMicStop').onclick = () => {
      try {
        if (processorNode) { processorNode.disconnect(); processorNode.onaudioprocess = null; }
        if (sourceNode) sourceNode.disconnect();
        if (audioCtx) audioCtx.close();
        if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
      } catch (e) {}
      processorNode = null; sourceNode = null; audioCtx = null; mediaStream = null;
      log('[mic] stopped');
    };

    function downsampleBuffer(buffer, sampleRate, outSampleRate) {
      if (outSampleRate === sampleRate) return buffer;
      const ratio = sampleRate / outSampleRate;
      const newLen = Math.round(buffer.length / ratio);
      const result = new Float32Array(newLen);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
        // simple average for cheap anti-aliasing
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = count > 0 ? (accum / count) : 0;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      let offset = 0;
      for (let i = 0; i < float32Array.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); // little-endian
      }
      return new Uint8Array(buffer);
    }
  </script>
</body>
</html>
